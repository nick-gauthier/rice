---
title: "Modeling the past and future climatic niche of rice"
author: "Nick Gauthier"
date: "`r Sys.Date()`"
format:
  html:
    theme: sandstone
editor: visual
knitr: 
  opts_chunk:
    echo: FALSE
bibliography: references.bib
---

```{r setup, message = TRUE, warning = TRUE}
# analysis packages
library(stars) # spatio-temporal raster processing
library(sf)
library(tidyverse)
library(tidymodels) # machine learning
library(terra)
library(here) # cross-platform directory structures
library(readxl) # read excel spreadsheets
# library(dismo) # generating background points for niche model, not loaded but should be installed
#library(Recocrop)

# parallel processing
library(doMC)
available_cores <- parallel::detectCores(logical = TRUE)

# visualization packages
library(rnaturalearth) # country boundaries
library(vip) # variable importance plots
library(pdp) # partial dependence plots

sf_use_s2(TRUE)

# define the study area
asia_bbox <- st_bbox(c(xmin = 60, xmax = 150, ymin = -20, ymax = 50), crs = 4326)
world_bbox <- st_bbox(c(xmin = -130, xmax = 155, ymin = -55, ymax = 60), crs = 4326)

# get country boundaries shapefile for plotting
countries <- ne_countries(returnclass = "sf", scale = 'large') %>%
  st_crop(asia_bbox)
coasts <- ne_coastline(returnclass = 'sf') %>%
  st_crop(asia_bbox)

chelsa_mask <- terra::rast('../../CHELSA_V2_bio_clim/CHELSA_pet_penman_mean_1981-2010_V.2.1.tif') %>%
      terra::crop(terra::ext(60, 150, -20, 50) ) #%>%
 # as('Raster')

theme_set(theme_bw())

load('data/data-derived/data_prepped.RData')
chelsa_files <- list.files('../../CHELSA_V2_bio_clim', 
                           full.names = TRUE)[c(2:20)]#, 31:33, 40:50, 52:59)]

chelsa_names <- chelsa_files %>% 
  str_split('_') %>% 
  map(~.x[5:7]) %>%
  map(~if_else(.x %in% c("1981-2010", "V.2.1.tif"), NA, .x)) %>%
  map_chr(str_flatten, collapse = '_', na.rm = TRUE)
chelsa <- rast('data/data-derived/chelsa_10km.nc') %>%
  setNames(chelsa_names)
cmip6 <- rast('data/data-derived/chelsa_cmip6_10km.nc') %>%
  setNames(chelsa_names)
```

# Introduction

Question: What is the fundamental thermal niche of rice? How has rice's niche changed in the past and how is it likely to change in the future? How sensitive is rice to changes in its thermal niche?

Hypotheses: Rice's fundamental thermal niche reflects both lower and upper bounds on temperature. Earlier in the Holocene temperatures were warmer, so rice was able to be grown further north. But although rice has adapted to increased cold it has not adapted to increased heat. Projected increases in heat will reduce the global rice niche without increasing it elsewhere.

# Methods

All analyses carried out in `R` [@base]. The entire analysis is run in a reproducible \`.qmd\` notebook.

## Preprocessing

All spatial data manipulation was carried out using the `sf`, `stars`, and `terra` packages [@terra; @stars; @sf].


### Data spliting

We randomly divided the occurrence data into a train test split, and further subdivided the training data into 5 folds, repeated 5 times, for cross validation. The train-test and 5-fold splits were both stratified by the presence-background outcome variable, so that the proportion of presence to background points was the same throughout. This ensures the models do not overfit to the high-prevalence background points.

```{r}
set.seed(12345)
splits <- initial_split(st_drop_geometry(dat), strata = presence)
train <- training(splits)
folds <- vfold_cv(train, v = 5, repeats = 5, strata = presence)
```

### Variable selection

We compared multiple models, including:

1.  All 19 Bioclimate variables
2.  Basic variables that can reasonably be reconstructed in the past: MAT, mean temperature of the warmest month, mean temperature of the coldest month, total annual precipitation, (growing degree days, PET, aridity index?)
3.  Just temperature related variables
4.  Additional moisture and terrain variables like PET, humidity, and solar radiation (soil PH)
5.  Stepwise model selection through BART



Other alternatives:
 - ramankutty et al 2002 -- gdd5, alpha, soil carbon density kg c/m2 and soil ph
 - TREELIM model
 - bio1, bio4, bio5, bio6, bio8, bio12, bio15 -- Edwards and Smoth 2010
 - [@mahaut2022] use Bio1, bio4, bio5, bio6, bio12, bio13, bio14, bio15 as indicators of mean and seasonality of precip and temp
 - minimal model from cang et al 2016, bio1, bio5, bio6, bio12


bio10 bio11 bio12 bio15 bio2 bio8 
we always get winter cold, summer heat, growing season temperature, rain, rain seasonality, and diurnal temperature range

```{r}
preprocessors <- 
  list(
    all = presence ~ .,
    expert = presence ~ bio1 + bio12 + bio5 + bio6 + bio4 + bio15 + bio8,
    minimal = presence ~ bio1 + bio12 + bio5 + bio6,
    mahaut = presence ~ bio1 + bio12 +  bio5 + bio6 + bio4 + bio13 + bio15 + bio14, 
    quart = presence ~ bio10 + bio11 + bio12 + bio15 + bio2 + bio8
)
```

## Analysis

### Random forests

We fit machine learning models using random forests, an ensemble-based machine learning method that makes predictions from an ensemble of several decisions trees. Random Forests have a high performance and low requirement for tunable parameters. Indeed, preliminary attempts to tune the number of variables selected per node (m_try) and minimum samples per node showed the default values for regression were performant so we elected to use the default values for simplicity.

```{r}
rf_mod <- rand_forest(mode = 'classification',
                      trees = 1000,
                      min_n = tune(),
                      mtry = tune()
                      ) %>%
  set_engine('ranger', replace = FALSE,
             importance = 'permutation',
             #splitrule = 'hellinger',
             sample.fraction = c(0.632 * prevalence, 
                                 0.632 * prevalence))

#rf_params_ <- rf_mod %>%
#  extract_parameter_set_dials() %>%
#  update(mtry = mtry(c(1L, 15L)))
```

Used the `tidymodels` framework for R, including the packages `parsnip`, `recipes`, `rsample`, and `yardstick` [@parsnip; @dials; @rsample; @recipes]. The underlying random forest algorithm relied on the implementation in the [@ranger] package.

We used balanced random forests to account for the low prevalence of the occurrence data relative to the environmental background points. Balanced random forests pull equal-sized samples of each category for the creation of each tree in the ensemble. This helps the model learn to detect the rare class, without throwing out potential information about the environmental background as would be required if the entire RF was fit on a single downsample. We grew the random forests by subsampling \~62% of the data without replacement.

```{r}
classes <- table(train$presence)
prevalence <- classes[1]/classes[2]
prevalence
```

### Model fitting

We evaluated our model based on several skill scores, the J, F index

```{r}
# error here effecting the rest?
c_metrics <- metric_set(roc_auc, pr_auc, f_meas, j_index, sens, yardstick::spec, yardstick::precision, kap)
```

```{r, cache = TRUE}
wflws <- workflow_set(preprocessors, list(rf = rf_mod))# %>%
  #option_add(param_info = params, id = c('all_rf', 'clim_rf')) %>%
   # option_add(param_info = params_min, id = c('minimal_rf'))

registerDoMC(cores = available_cores)
#wflw_fits <- workflow_map(wflws, 'tune_bayes', initial = 20, resamples = folds, 
 #                         metrics = c_metrics,  seed = 3, verbose = TRUE)
wflw_fits <- workflow_map(wflws, 'tune_grid', grid = 10, resamples = folds, 
                          metrics = c_metrics,  seed = 3, verbose = TRUE)
#wflw_fits <- workflow_map(wflws, 'fit_resamples', resamples = folds, 
#                          metrics = c_metrics,  seed = 3, verbose = TRUE)
registerDoSEQ()

saveRDS(wflw_fits, 'data/data-derived/wflw_fits.rds')
```


## Model evaluation

performance improvement.

model selection and fitting

we compared several model configurations in our cross validation scheme

Permutation based variable importance

we used partial dependence plots

assessed area of applicability using [@applicable].

```{r}
wflw_fits <- readRDS(here('data/data-derived/wflw_fits.rds'))

rank_results(wflw_fits, rank_metric = 'pr_auc') %>%
  ggplot(aes(rank, mean, color = wflow_id))+
  geom_linerange(aes(ymin = mean - std_err * qnorm(0.95), ymax = mean + std_err * qnorm(0.95))) +
  geom_point() +
  facet_wrap(~.metric, scales = 'free_y')
```


```{r}
autoplot(wflw_fits, id = 'all_rf')
autoplot(wflw_fits, id = 'mahaut_rf')
autoplot(wflw_fits, id = 'expert_rf')
autoplot(wflw_fits, id = 'minimal_rf')
```

For the f_meas, mtry 8 for all model and 2 for the others --- close to defaults but more conservative by a bit. min_n 7, 10, and 6.

```{r}
wflw_fits %>% 
  extract_workflow_set_result("all_rf") %>% 
  select_best(metric = 'f_meas')
wflw_fits %>% 
  extract_workflow_set_result("expert_rf") %>% 
  select_best(metric = 'f_meas')
wflw_fits %>% 
  extract_workflow_set_result("minimal_rf") %>% 
  select_best(metric = 'f_meas')
wflw_fits %>% 
  extract_workflow_set_result("mahaut_rf") %>% 
  select_best(metric = 'f_meas')
```

Interestingly pr_auc selects mtry 2 for both all and expert --- I wonder what the variable importance looks like in al for mtry 2. min_n is 10, 7, 4. 

```{r}
wflw_fits %>% 
  extract_workflow_set_result("all_rf") %>% 
  select_best(metric = 'pr_auc')
wflw_fits %>% 
  extract_workflow_set_result("expert_rf") %>% 
  select_best(metric = 'pr_auc')
wflw_fits %>% 
  extract_workflow_set_result("minimal_rf") %>% 
  select_best(metric = 'pr_auc')
wflw_fits %>% 
  extract_workflow_set_result("mahaut_rf") %>% 
  select_best(metric = 'pr_auc')


wflw_fits %>% 
  extract_workflow_set_result("all_rf") %>% 
  select_best(metric = 'roc_auc')
wflw_fits %>% 
  extract_workflow_set_result("expert_rf") %>% 
  select_best(metric = 'roc_auc')
wflw_fits %>% 
  extract_workflow_set_result("mahaut_rf") %>% 
  select_best(metric = 'roc_auc')
wflw_fits %>% 
  extract_workflow_set_result("minimal_rf") %>% 
  select_best(metric = 'roc_auc')
wflw_fits %>% 
  extract_workflow_set_result("quart_rf") %>% 
  select_best(metric = 'roc_auc')

collect_metrics(wflw_fits, ) %>%
  filter(.metric == 'pr_auc') %>% 
  group_by(wflow_id) %>%
  summarise(pr_auc = max(mean)) %>% 
  arrange(-pr_auc)
collect_metrics(wflw_fits, ) %>%
  filter(.metric == 'roc_auc') %>% 
  group_by(wflow_id) %>%
  summarise(roc_auc = max(mean)) %>% 
  arrange(-roc_auc)
collect_metrics(wflw_fits, ) %>%
  filter(.metric == 'f_meas') %>% 
  group_by(wflow_id) %>%
  summarise(f_meas = max(mean)) %>% 
  arrange(-f_meas)
```



Refit the wining model to get predictions

Bio3, bio11, rsdsrange ... bio4, 10, 1, rsds min, pet min. for simples model is mean temp coldest and mean.

just bioclim gives 3, 6, 11, 1, 10, 4, 12

```{r}
mod1 <- wflw_fits %>% 
  extract_workflow_set_result("all_rf") %>% 
  select_best(metric = 'roc_auc') %>%
  finalize_workflow(extract_workflow(wflw_fits, 'all_rf'), .) %>%
  fit(train)

mod2 <- wflw_fits %>% 
  extract_workflow_set_result("expert_rf") %>% 
  select_best(metric = 'roc_auc') %>%
  finalize_workflow(extract_workflow(wflw_fits, 'expert_rf'), .) %>%
  fit(train)

mod3 <- wflw_fits %>% 
  extract_workflow_set_result("quart_rf") %>% 
  select_best(metric = 'roc_auc') %>%
  finalize_workflow(extract_workflow(wflw_fits, 'quart_rf'), .) %>%
  fit(train)

pred1 <- chelsa %>%
  predict(mod1, type = 'prob') %>%
  st_as_stars() %>%
  setNames('presence')

pred2 <- chelsa %>%
  predict(mod2, type = 'prob') %>%
  st_as_stars()%>%
  setNames('presence')

pred3 <- chelsa %>%
  predict(mod3, type = 'prob') %>%
  st_as_stars()%>%
  setNames('presence')

ggplot() +
  geom_stars(data = pred1[,,,1])  +
  #geom_sf(data = coasts, color = 'black') +
  scale_fill_viridis_c(na.value = 'white', limits = c(0, 1)) +
  theme_void()
ggplot() +
  geom_stars(data = pred2[,,,1])  +
  #geom_sf(data = coasts, color = 'black') +
  scale_fill_viridis_c(na.value = 'white', limits = c(0, 1)) +
  theme_void()
ggplot() +
  geom_stars(data = pred3[,,,1])  +
  #geom_sf(data = coasts, color = 'black') +
  scale_fill_viridis_c(na.value = 'white', limits = c(0, 1)) +
  theme_void()
```
prediction
```{r}
future_pred <- cmip6 %>%
  predict(mod1, type = 'prob', na.rm = TRUE) %>%
    st_as_stars() %>%
  setNames('future')

future_pred2 <- cmip6 %>%
  predict(mod2, type = 'prob', na.rm = TRUE) %>%
    st_as_stars() %>%
  setNames('future')

future_pred3 <- cmip6 %>%
  predict(mod3, type = 'prob', na.rm = TRUE) %>%
    st_as_stars() %>%
  setNames('future')
```

```{r}
ggplot() +
  geom_stars(data = future_pred[,,,1]) +
  scale_fill_viridis_c(limits = c(0, 1)) +
 # geom_sf(data = coasts %>% st_crop(asia_bbox), color = 'white') +
    theme_void()
ggplot() +
  geom_stars(data = pred1[,,,1])  +
  #geom_sf(data = coasts %>% st_crop(asia_bbox), color = 'white') +
  scale_fill_viridis_c(limits = c(0, 1)) +
  theme_void()
ggplot() +
  geom_stars(data = future_pred2[,,,1]) +
  scale_fill_viridis_c(limits = c(0, 1)) +
 # geom_sf(data = coasts %>% st_crop(asia_bbox), color = 'white') +
    theme_void()
ggplot() +
  geom_stars(data = pred2[,,,1])  +
  #geom_sf(data = coasts %>% st_crop(asia_bbox), color = 'white') +
  scale_fill_viridis_c(limits = c(0, 1)) +
  theme_void()
ggplot() +
  geom_stars(data = future_pred3[,,,1]) +
  scale_fill_viridis_c(limits = c(0, 1)) +
 # geom_sf(data = coasts %>% st_crop(asia_bbox), color = 'white') +
    theme_void()
ggplot() +
  geom_stars(data = pred3[,,,1])  +
  #geom_sf(data = coasts %>% st_crop(asia_bbox), color = 'white') +
  scale_fill_viridis_c(limits = c(0, 1)) +
  theme_void()


ggplot() +
  geom_stars(data = future_pred - pred1)  +
  geom_sf(data = coasts %>% st_crop(asia_bbox), color = 'black') +
  scale_fill_distiller(limits = c(-1, 1), palette = 'RdBu', direction = 1) +
  theme_void()
ggplot() +
  geom_stars(data = future_pred2 - pred2)  +
  geom_sf(data = coasts %>% st_crop(asia_bbox), color = 'black') +
  scale_fill_distiller(limits = c(-1, 1), palette = 'RdBu', direction = 1) +
  theme_void()
ggplot() +
  geom_stars(data = future_pred3 - pred3)  +
  geom_sf(data = coasts %>% st_crop(asia_bbox), color = 'black') +
  scale_fill_distiller(limits = c(-1, 1), palette = 'RdBu', direction = 1) +
  theme_void()
```

Variable importance  plots

```{r}
mod1 %>%
  extract_fit_engine() %>%
  vip(geom = "point", num_features = 19)

mod2 %>%
  extract_fit_engine() %>%
  vip(geom = "point")
mod3 %>%
  extract_fit_engine() %>%
  vip(geom = "point")
```

Partial Dependence Plots

```{r}
library(pdp)
mod3 %>%
  extract_fit_engine() %>%
  pdp::partial(pred.var = 'bio11', train = train, 
        plot.engine = 'ggplot2', prob = TRUE, progress = TRUE) %>%
              plotPartial(lwd = 2, rug = TRUE, train = train)

mod3 %>%
  extract_fit_engine() %>%
  pdp::partial(pred.var = 'bio10', train = train, 
        plot.engine = 'ggplot2', prob = TRUE, progress = TRUE) %>%
              plotPartial(lwd = 2, rug = TRUE, train = train)
mod3 %>%
  extract_fit_engine() %>%
  pdp::partial(pred.var = 'bio2', train = train, 
        plot.engine = 'ggplot2', prob = TRUE, progress = TRUE) %>%
              plotPartial(lwd = 2, rug = TRUE, train = train)
mod3 %>%
  extract_fit_engine() %>%
  pdp::partial(pred.var = 'bio12', train = train, 
        plot.engine = 'ggplot2', prob = TRUE, progress = TRUE) %>%
              plotPartial(lwd = 2, rug = TRUE, train = train)


mod3 %>%
  extract_fit_engine() %>%
  pdp::partial(pred.var = 'bio10', train = train, ice = TRUE, alpha = .05,
        plot.engine = 'ggplot2', prob = TRUE, progress = TRUE, plot = TRUE, lwd = 2, rug = TRUE,smooth = TRUE)
```



### GAM
bio10 bio11 bio12 bio15 bio2 bio8 

```{r}
library(mgcv)
## add weights!
test_gam <- train %>%
  mutate(presence = factor(presence, levels = c(0, 1))) %>%
#  mutate(species = as.factor(species)) %>%
    bam(presence ~ s(bio10,  bs = 'cr', k = 6)+ s(bio11, bs = 'cr', k = 6) + s(bio12, bs = 'cr', k = 6) +  s(bio15,  bs = 'cr', k = 6) +  s(bio2,  bs = 'cr', k = 6) +  s(bio8,  bs = 'cr', k = 6), data = ., family = binomial(), select = TRUE)

summary(test_gam)

plot(test_gam,rug = TRUE)
plot(test_gam, trans = plogis, rug = TRUE)
```




```{r}
plot((chelsa[['bio1']] > 30));plot(cmip6[['bio1']] > 30)
plot(cmip6[['bio1']])
plot(chelsa[['bio1']] - cmip6[['bio1']])
```

```{r}
plot(chelsa[['bio12']]) ;plot(cmip6[['bio12']])
plot(chelsa[['bio5']] > 36) ;plot(cmip6[['bio5']] > 36)
plot(chelsa[['bio11']] > 25) ;plot(cmip6[['bio11']] > 25)
```




### ECOCROP

As a simple baseline for our niche models we also used the semi-mechanistic expert-informed estimates from the ECOCROP model.

```{r ecocrop}
thresh <- factor(c('min', 'low_opt', 'high_opt', 'max'),
       levels = c('min', 'low_opt', 'high_opt', 'max'))

rice_list <- list('Rice paddy (Japonica)',
     'Rice upland (Japonica)',
     'Rice, paddy (Indica)',
    'Rice upland (Indica)',
    'Bulu rice (Javanica)',
    'African rice') 

rice_list %>%
  set_names(rice_list) %>%
  map(~Recocrop::ecocropPars(.x)$parameters) %>%
  map(as_tibble) %>%
  map(~mutate(.x, threshold = thresh, .before = 1)) %>%
  list_rbind(names_to = 'type') %>%
  select(type, threshold, tavg) %>%
  pivot_wider(names_from = 'threshold', 
              values_from = 'tavg')
```

Niche projections

niche stability

# Results

## Climate influences on rice niche
```{r}
train %>%
   filter(presence == 1) %>%
  select(bio1:bio9) %>%
  pivot_longer(bio1:bio9, names_to = 'bio') %>%
  ggplot(aes(value)) +
  geom_histogram()+
  facet_wrap(~bio, scales = 'free')

train %>%
  pivot_longer(bio1:bio9, names_to = 'bio') %>%
  ggplot(aes(value)) +
  geom_density(aes(color = presence),)+
  facet_wrap(~bio, scales = 'free')

train %>%
   filter(presence == 0) %>%
  select(bio1:bio9) %>%
  select(-c(bio14, bio17, bio19)) %>%
  pivot_longer(bio1:bio9, names_to = 'bio') %>%
  ggplot(aes(value)) +
  geom_density()+
  scale_fill_brewer(palette = 'Spectral') +
  facet_wrap(~bio, scales = 'free')

train %>%
  ggplot(aes(bio1, bio12)) +
  geom_point(aes(color= presence), alpha = 0.1) 
```
```{r}
## this doesn't account for the larger sample size from O. sativa though
train %>%
    #  filter(presence == 1) %>%
  recipe() %>%
  update_role(starts_with('bio'), new_role = 'predictor') %>%
  update_role(presence, new_role = 'outcome') %>%
  step_normalize(all_numeric_predictors()) %>%
  step_pca(all_numeric_predictors(), num_comp = 2) %>%
  prep %>%
  juice %>%
  ggplot(aes(PC1, PC2)) + 
  stat_ellipse(aes(color = presence)) +
  #geom_point() +
 # geom_hex(aes(fill = species)) +
  coord_equal() #+
 # facet_wrap(~species)
```


```{r}
library(mgcv)
test_gam <- train %>%
  mutate(presence = factor(presence, levels = c(0, 1))) %>%
  bam(presence ~ s(bio1) + s(bio12) + s(bio5) + s(bio6), data = ., method = "fREML", family = binomial("logit"), select = TRUE)


plot(test_gam, trans = plogis, rug = TRUE
     )
```

How do these estimates compare to the EcoCROP data?

```{r}
rice_list %>%
  set_names(rice_list) %>%
  map(~Recocrop::ecocropPars(.x)$parameters) %>%
  map(as_tibble) %>%
  map(~mutate(.x, threshold = thresh, .before = 1)) %>%
  list_rbind(names_to = 'type') %>%
  select(type, threshold, tavg) %>%
  pivot_wider(names_from = 'threshold', 
              values_from = 'tavg')
```


## Changing rice niches in the Holocene

### Beyer et al data

```{r}
#hadcm3
#devtools::install_github("EvolEcolGroup/pastclim")
#citation("pastclim")
#help("Beyer2020")
biovars <- c('bio01', 'bio02', 'bio03', 'bio04', 'bio05', 'bio06', 'bio07', 'bio08', 'bio09', 'bio10', 'bio11', 'bio12', 'bio13', 'bio14', 'bio15', 'bio16', 'bio17', 'bio18', 'bio19')[-c(2:3)]
library(pastclim)
set_data_path(path_to_nc = here('data/data-raw/beyer/'))
get_vars_for_dataset(dataset = "Beyer2020")
get_vars_for_dataset(dataset = "Krapp2021")

download_dataset(dataset = "Beyer2020", bio_variables = biovars)
download_dataset(dataset = "Krapp2021", bio_variables = biovars)

climate_region <- region_series(
  time_bp = list(min = -6000), 
  bio_variables = biovars,
  ext= terra::ext(60, 150, -20, 50),
  dataset = "Beyer2020")

climate_region8 <- region_slice(
  time_bp = -8000, 
  bio_variables = biovars,
  ext= terra::ext(60, 150, -20, 50),
  dataset = "Beyer2020")
climate_region7 <- region_slice(
  time_bp = -7000, 
  bio_variables = biovars,
  ext= terra::ext(60, 150, -20, 50),
  dataset = "Beyer2020")
climate_region6 <- region_slice(
  time_bp = -6000, 
  bio_variables = biovars,
  ext= terra::ext(60, 150, -20, 50),
  dataset = "Beyer2020")
climate_region5 <- region_slice(
  time_bp = -5000, 
  bio_variables = biovars,
  ext= terra::ext(60, 150, -20, 50),
  dataset = "Beyer2020")
climate_region4 <- region_slice(
  time_bp = -4000, 
  bio_variables = biovars,
  ext= terra::ext(60, 150, -20, 50),
  dataset = "Beyer2020")
climate_region3 <- region_slice(
  time_bp = -3000, 
  bio_variables = biovars,
  ext= terra::ext(60, 150, -20, 50),
  dataset = "Beyer2020")
climate_region2 <- region_slice(
  time_bp = -2000, 
  bio_variables = biovars,
  ext= terra::ext(60, 150, -20, 50),
  dataset = "Beyer2020")
climate_region1 <- region_slice(
  time_bp = -1000, 
  bio_variables = biovars,
  ext= terra::ext(60, 150, -20, 50),
  dataset = "Beyer2020")

mh_pred  <- list(climate_region8, climate_region7, climate_region6, climate_region5, climate_region4, climate_region3, climate_region2, climate_region1) %>%
  map(setNames, paste0('bio', 1:19)[-c(2:3)]) %>%
  map(~ predict(.x, simp_fit, type = 'prob', na.rm = TRUE) %>% st_as_stars() %>%
  slice('band', 1)) %>%
  do.call(c, .) %>%
  setNames(c('8ka', '7ka', '6ka', '5ka', '4ka', '3ka', '2ka', '1ka')) %>%
  merge() %>%
  setNames('niche_prob')

ggplot() +
  geom_stars(data = mh_pred) +
  scale_fill_viridis_c() +
  facet_wrap(~attributes)
ggplot() + geom_stars(data = slice(mh_pred, 'attributes', 1) - slice(mh_pred, 'attributes', 8)) + scale_fill_distiller(palette = 'RdBu', na.value = NA, limits = c(-.9, .9))


#climate_region[[1]][[1]]
#beyer_delta <- st_as_stars(climate_region[[1]] - climate_region[[1]][[8]])
#ggplot() + geom_stars(data = beyer_delta) + scale_fill_distiller(palette = 'RdBu', na.value = NA, limits = c(-4.2, 4.2)) + facet_wrap(~time)
```

```{r}
# it wants time to be positively increasing?
ggplot() +
  geom_stars(data = (erb[,,,-c(1,8:9)] - slice(erb, 'time', 1)) %>% st_crop(countries %>% st_crop(asia_bbox))) +
  facet_wrap(~time) +
  #scale_fill_viridis_c(option = 'magma') +
  scale_fill_distiller(palette = 'RdBu', na.value = 'white', limits = c(-.7, .7)) +
  geom_sf(data = st_crop(coasts, asia_bbox))
#rm(erb_rotated, times)


  
  library(tidyEOF)
plot_scree(erb_decadal %>% filter(time >= -7000), scale = TRUE)
pat <- get_patterns(erb_decadal %>% filter(time >= -7000), 
                    k = 3, scale = TRUE, rotate = TRUE)
plot_eofs(pat) +
  geom_sf(data = coasts %>% st_crop(asia_bbox))
plot_amps(pat, scaled = FALSE, c(-4200)) +
  scale_x_reverse()
```

Now get correlation between each pattern and SST and MAT reconstructions globally.

Now plot the climate reconstruction and niche data for 9k to present

```{r}
arch %>%
  mutate(time = (age - age %% 1000) /1000 + 1) %>%
  ggplot() +
  geom_stars(data = erb - slice(erb, 'time', 1)) +
  scale_fill_distiller(palette = 'RdBu', limits = c(-.5, .5)) +
  geom_sf(size = 0.5) + 
  geom_sf(data = coasts %>% st_crop(asia_bbox)) +
  facet_wrap(~time)

test_erb <- as(erb, 'SpatRaster') +  as(trace_mean_5bp_3bp, 'SpatRaster') 
plot(test_erb[[1]] - test_erb[[9]])
  ggplot() +
  geom_stars(data = st_as_stars(test_erb)[,,,1:6] - slice(st_as_stars(test_erb), 'band', 1)) +
  scale_fill_distiller(palette = 'RdBu', limits = c(-1, 1)) +
  geom_sf(size = 0.5) + 
  geom_sf(data = coasts %>% st_crop(asia_bbox)) +
  facet_wrap(~band)
```

```{r}
chelsa <- terra::rast(here('data/data-derived/chelsa_10km.nc')) %>%
    setNames(chelsa_names)

erb_test <- erb_decadal %>%
  st_set_dimensions('x', point = FALSE) %>%
  st_set_dimensions('y', point = FALSE) %>%
  filter()

erb_test2 <- units::drop_units(erb_test) + trace_mean_5bp_3bp

arch %>%
   # filter(age > -7000) %>%
  select(age) %>%
  mutate(time = age) %>%
  st_extract(erb_test2[,,,1200:1], ., time_column = 'time', interpolate_time = FALSE) %>%
  ggplot(aes(time, tas)) +
  geom_point()

 test_interp <-  erb_test2 %>% as('SpatRaster') %>%
   disagg(fact = 5, method = 'bilinear') %>%
   st_as_stars() %>%
   st_set_dimensions('band', names = 'time', values = st_get_dimension_values(erb_test, 'time')) %>% setNames('tas')
 
test_chelsa <-  read_stars('data/data-derived/chelsa_10km.nc') %>%
   st_as_stars() %>%
   slice('var', 2)


arch %>%
   # filter(age > -7000) %>%
  select(age) %>%
  mutate(time = age) %>%
  st_extract(test_interp[,,,1200:1], ., time_column = 'time', interpolate_time = TRUE) %>%
  mutate(country = arch$Country) %>%
  ggplot(aes(time, tas)) +
  geom_point(aes(color = country)) +
   scale_y_continuous(limits = c(-10, 30)) +
    scale_x_continuous(breaks = seq(-8000, 0, 1000))

  arch %>%
   # filter(age > -7000) %>%
  select(age) %>%
  mutate(time = age) %>%
  st_extract(test_chelsa, .) %>%
  mutate(country = arch$Country, time = arch$age) %>%
  ggplot(aes(time, chelsa_10km.nc)) +
  geom_point(aes(color = country)) +
   scale_y_continuous(limits = c(-10, 30)) +
    scale_x_continuous(breaks = seq(-8000, 0, 1000))
```

```{r}
plot((as.numeric(!is.na(chelsa[['ai']])) * chelsa[['bio1']]) > 27)
```

### Envirem

```{r}
envirem_gdd5 <- read_stars('~/Downloads/Eurasia_holo_ccsm4_10arcmin_geotiff/holo_ccsm4_10arcmin_growingDegDays5.tif') %>%
  st_set_crs(4326) %>%
  st_crop(ref) %>%
  setNames('GDD5')

envirem_gdd52 <- read_stars('~/Downloads/Eurasia_holo_miroc_esm_5arcmin_geotiff/holo_miroc_esm_5arcmin_growingDegDays5.tif') %>%
  st_set_crs(4326) %>%
  st_crop(ref) %>%
  setNames('GDD5')

envirem_gdd53 <- read_stars('~/Downloads/Eurasia_current_5arcmin_geotiff/current_5arcmin_growingDegDays5.tif') %>%
  st_set_crs(4326) %>%
  st_crop(ref) %>%
  setNames('GDD5')

ggplot() + 
  geom_stars(data = (envirem_gdd5 / 10) > 2900) +
  geom_sf(data = coasts) +
  scale_fill_viridis_d(option = 'magma', na.value = NA) +
  theme_void()
ggplot() + 
  geom_stars(data = (envirem_gdd52 / 10) > 2900) +
  geom_sf(data = coasts) +
  scale_fill_viridis_d(option = 'magma', na.value = NA) +
  theme_void()
ggplot() + 
  geom_stars(data = (envirem_gdd53 / 10) > 2900) +
  geom_sf(data = coasts) +
  scale_fill_viridis_d(option = 'magma', na.value = NA) +
  theme_void()
```

### TRACE

```{r}

```

```{r}

```

```{r}
ggplot() + geom_stars( data = st_apply(trace_gdd, 1:2, mean)) + scale_fill_viridis_c(option = 'magma')+ geom_sf(data = coasts)
ggplot() + geom_stars( data = st_apply(trace_gdd, 1:2, sd)) + scale_fill_viridis_c(option = 'magma')+ geom_sf(data = coasts)
#ggplot() + geom_stars( data = st_apply(trace_gdd, 1:2, sd) / st_apply(trace_gdd, 1:2, mean)) + scale_fill_viridis_c(option = 'magma', trans = 'log') + geom_sf(data = coasts)
```

```{r}
ggplot() + geom_stars( data = st_apply(trace_gdd, 1:2, function(x) sum(x > 2900) / length(x))) + scale_fill_viridis_c(option = 'magma')+ geom_sf(data = coasts) + theme_void()
```

## Projected changes in rice suitability

# Discussion

Climate/genetic correlations from [@gutaker2020] match these more or less.

accumulated heat days (GDD) is a common measure for rice's thermal niche [@dalpoimguedes2016]. We consistently find GDD is not a good predictor of rice presences at this spatial and temporal scale. At this scale GDD is highly correlated with annual and seasonal temperature changes, while at the local scale its realized gdd also reflects things like local topography, solar radiation, and the particular timing of its planting and growing season initiation. We conclude, that at regional spatial scales, temperature is a better indicator of rice's thermal niche. It is an easier variable to calculate (and indeed GDD estimates are often themselves inferred from temperature cycles) in the past and future and is less dependent on particular cultural practices. Future work should work to connect these regional correlative models with local mechanistic ones, incorporating local terrain information and cultivar and cultural information about the timing and initiation of planting and the growing period.

planting times

> ering some of the world's most important rice areas with three distinct cropping seasons, such as in Bangladesh, where *aman* rice (main rainy season) is harvested in November-December; *boro* (dry season) in April-May; and *aus* in July-August. Parts of Vietnam also have three cropping seasons---winter-spring, spring-summer, and summer-autumn---and this is also the case in parts of China (early and late seasons for double-cropped rice areas; and middle for single-cropped rice areas) and India. https://www.nature.com/articles/sdata201774

## Limitations

spatial and temporal correspondence

rice occurrence data

modeling issues presence-background

genetic variability

unceratiny in radioarbon

## Future work

whole genus?

# References

# Supplement

### Bayesian additive regression trees

As a complement to traditional random forests, we also employ a Bayesian implementation of tree-based ensemble machine learning methods. Bayesian additive regression trees (BART) allow for flexible modeling through regularization. Flexible benefits of other boosting methods but without the need to tune several hyperparameters. It also works favorably for stepwise model selection, as the Bayesian implementation makes assessing variable importance straightforward.

```{r}
bart_mod <- parsnip::bart(mode = 'classification',
                          trees = tune(),
                          prior_terminal_node_coef = tune(),
                          prior_terminal_node_expo = tune(),
                          prior_outcome_range = tune()
                          )
```

code for plotting distributions of multiple species simultaneously

```{r}
train %>%
   filter(presence == 1) %>%
  select(bio1:bio9, species) %>%
  pivot_longer(bio1:bio9, names_to = 'bio') %>%
  ggplot(aes(value)) +
  geom_histogram()+
  facet_grid(species~bio, scales = 'free')

train %>%
   filter(presence == 1) %>%
  select(bio1:bio9, species) %>%
  select(-c(bio14, bio17, bio19)) %>%
  pivot_longer(bio1:bio9, names_to = 'bio') %>%
  ggplot(aes(value)) +
  geom_density(aes(fill = species), position = 'stack')+
  scale_fill_brewer(palette = 'Spectral') +
  facet_wrap(~bio, scales = 'free')

train %>%
   filter(presence == 0) %>%
  select(bio1:bio9, species) %>%
  select(-c(bio14, bio17, bio19)) %>%
  pivot_longer(bio1:bio9, names_to = 'bio') %>%
  ggplot(aes(value)) +
  geom_density(aes(fill = species), position = 'stack')+
  scale_fill_brewer(palette = 'Spectral') +
  facet_wrap(~bio, scales = 'free')

train %>%
  filter(presence == 1)  %>%
  ggplot(aes(bio1, bio12)) +
  geom_point(aes(color= species), alpha = 0.1) +
  scale_color_brewer(palette = 'Spectral') +
  facet_wrap(~species)
```

### PCA

```{r}
#devtools::install_github("tidymodels/learntidymodels")
train %>%
  recipe(presence ~ .) %>%
  step_normalize(all_numeric_predictors()) %>%
  step_pca(all_numeric_predictors(), threshold = 0.9) %>%
  prep() %>%
  learntidymodels::plot_top_loadings(component_number <= 5, n = 5) 


train %>%
  select(-presence) %>%
  prcomp(center = TRUE, scale. = TRUE)
```
```{r fig.width = 10, fig.height = 10}
train[,-1] %>% as.matrix %>% cor() %>% corrplot::corrplot.mixed(order = 'AOE', lower = 'square', upper = 'number')
```

```{r}
train %>%
  recipe(presence ~ .) %>%
  step_corr(all_numeric_predictors(), threshold = 0.8) %>%
  prep()
```
```{r}
library(applicable)
predictors <- train[,-1]
ap_mod <- apd_pca(predictors)
ap_mod
autoplot(ap_mod)

ap_pred <- cmip6 %>%
  as_tibble() %>%
  score(ap_mod, .)

# RCP8.5 is above 80 percentile warmer
setValues(cmip6[[1]], ap_pred$distance_pctl) %>% plot()
setValues(cmip6[[1]], ap_pred$PC1) %>% plot()
setValues(cmip6[[1]], ap_pred$PC1_pctl) %>% plot()
setValues(cmip6[[1]], ap_pred$distance) %>% plot()


comp1 <- ap_mod$pcs$rotation[,1]
comp1[order(abs(comp1), decreasing = TRUE)] %>% head(5)
```
This suggests it would be nice to use a larger spatial domain so that we're sampling a wider range of climates to help with extrapolation? Either way, PCs are unstable for prediction here so need to make a choice about using them to understand the model vs alternatives.
